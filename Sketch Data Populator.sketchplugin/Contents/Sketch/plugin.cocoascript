//===============================================
// sketch data populator - plugin
//===============================================

@import 'lodash.get.cocoascript';
@import 'library.cocoascript';

var context;
var selection;

function populateWithPresetHandler(_context) {
	context = _context;

	//get user defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//load presets
	var presets = Library.loadPresets();
	if(!presets.length) {
		context.document.showMessage('There are no presets.');
		return;
	}

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get preset names array
	var presetNames = [];
	presets.forEach(function(preset) {
		presetNames.push(preset.name);
	});

	//create alert
	var alert = Library.createAlert("Populate with Preset", "Please select the Preset you'd like to use to populate your design and configure the options.", "icon.png");

	//create list view
	var listView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 50)];
	[alert addAccessoryView: listView];

	//create preset list title
	var presetListTitle = Library.createLabel('Select Preset', 12, true, NSMakeRect(0, 30, 300, 20));
	[listView addSubview: presetListTitle];

	//create preset list
	var presetList = Library.createSelect(presetNames, 0, NSMakeRect(0, 0, 300, 25)];
	[listView addSubview: presetList];

	//select last selected preset
	var lastSelectedPresetIndex = [defaults objectForKey:'selectedPresetIndex'];
	if(lastSelectedPresetIndex && lastSelectedPresetIndex < presetNames.length) {
		[presetList selectItemAtIndex: lastSelectedPresetIndex];
	}

	//add space
	var spacerView = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView];

	//create data options view
	var dataOptionsView = Library.createDataOptionsView();
	[alert addAccessoryView: dataOptionsView.view];

	//add space
	var spacerView2 = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView2];

	//create layout options view
	var layoutOptionsView = Library.createLayoutOptionsView();
	[alert addAccessoryView: layoutOptionsView.view];

	//add bottom buttons
	[alert addButtonWithTitle:"Populate"];
	[alert addButtonWithTitle:"Cancel"];

	//set rows textfield as first responder
	var alertWindow = [[alert alert] window];
	[alertWindow setInitialFirstResponder: layoutOptionsView.rowsCountTextField];
	[alertWindow setAutorecalculatesKeyViewLoop: true];

	//show alert
	var responseCode = [alert runModal];
	if(responseCode == '1000') {

		//get selected preset index
		var selectedPresetIndex = [presetList indexOfSelectedItem];

		//get preset paths
		var presetPath = [NSString stringWithString: presets[selectedPresetIndex].path];
		var presetParentDir = [presetPath stringByDeletingLastPathComponent];

		//== data options =======================

		//get randomize checkbox state
		var randomizeCheckbox = dataOptionsView.randomizeCheckbox;
		var randomizeData = Number([randomizeCheckbox state]);

		//get trim checkbox state
		var trimCheckbox = dataOptionsView.trimCheckbox;
		var trimText = Number([trimCheckbox state]);

		//get ellipsis checkbox state
		var ellipsisCheckbox = dataOptionsView.ellipsisCheckbox;
		var insertEllipsis = Number([ellipsisCheckbox state]);

		//get default substitute
		var substituteTextField = dataOptionsView.substituteTextField;
		var defaultSubstitute = [substituteTextField stringValue];

		//== layout options =====================

		//get create grid checkbox state
		var createGridCheckbox = layoutOptionsView.createGridCheckbox;
		var isCreateGrid = Number([createGridCheckbox state]);

		//get grid config
		var rowsCountTextField = layoutOptionsView.rowsCountTextField;
		var rowsCount = Number([rowsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var rowsMarginTextField = layoutOptionsView.rowsMarginTextField;
		var rowsMargin = Number([rowsMarginTextField stringValue].replace(/\,/g, '.'));
		var columnsCountTextField = layoutOptionsView.columnsCountTextField;
		var columnsCount = Number([columnsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var columnsMarginTextField = layoutOptionsView.columnsMarginTextField;
		var columnsMargin = Number([columnsMarginTextField stringValue].replace(/\,/g, '.'));

		//save data options
		[defaults setObject: selectedPresetIndex forKey: 'selectedPresetIndex'];
		[defaults setObject: presetPath forKey: 'dataPath'];
		[defaults setObject: 'preset' forKey: 'populateMethod'];
		[defaults setObject: randomizeData forKey: 'randomizeData'];
		[defaults setObject: trimText forKey: 'trimText'];
		[defaults setObject: insertEllipsis forKey: 'insertEllipsis'];
		[defaults setObject: defaultSubstitute forKey: 'defaultSubstitute'];

		//save layout options
		[defaults setObject: isCreateGrid forKey: 'createGrid'];
		[defaults setObject: rowsCount forKey: 'rowsCount'];
		[defaults setObject: rowsMargin forKey: 'rowsMargin'];
		[defaults setObject: columnsCount forKey: 'columnsCount'];
		[defaults setObject: columnsMargin forKey: 'columnsMargin'];

		//sync defaults
		[defaults synchronize];

		//load data
		var presetData = Library.loadJSONData(presetPath);

		//create grid
		if(isCreateGrid) {
			selectedLayers = Library.createGrid(selectedLayers, {
				rowsCount: rowsCount,
				rowsMargin: rowsMargin,
				columnsCount: columnsCount,
				columnsMargin: columnsMargin
			});
			selection = selectedLayers;

			//make sure that grid creation was successful
			if(!selectedLayers) {
				return;
			}
		}
		
		//populate design with data
		populate(presetData, selectedLayers, {
			rootDir: presetParentDir,
			randomizeData: randomizeData,
			trimText: trimText,
			insertEllipsis: insertEllipsis,
			defaultSubstitute: defaultSubstitute
		});
	}
}


function populateWithJSONHandler(_context) {
	context = _context;

	//get user defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get last used location
	var defaults = [NSUserDefaults standardUserDefaults];
	var lastLocation = [defaults objectForKey: 'LastJSONFilePickerLocation'];

	//get JSON file path
	var filePath = Library.askForJSON(lastLocation);
	if(!filePath) return;

	//save last used location
	[defaults setObject: filePath forKey: 'LastJSONFilePickerLocation'];
	[defaults synchronize];

	//get root dir
	var rootDir = [filePath stringByDeletingLastPathComponent];

	//create alert
	var alert = Library.createAlert("Populate with JSON", "Please configure the options below.", "icon.png");

	//create data options view
	var dataOptionsView = Library.createDataOptionsView();
	[alert addAccessoryView: dataOptionsView.view];

	//add space
	var spacerView2 = [[NSView alloc] initWithFrame: NSMakeRect(0, 0, 300, 5)];
	[alert addAccessoryView: spacerView2];

	//create layout options view
	var layoutOptionsView = Library.createLayoutOptionsView();
	[alert addAccessoryView: layoutOptionsView.view];

	//add bottom buttons
	[alert addButtonWithTitle:"Populate"];
	[alert addButtonWithTitle:"Cancel"];

	//set rows textfield as first responder
	var alertWindow = [[alert alert] window];
	[alertWindow setInitialFirstResponder: layoutOptionsView.rowsCountTextField];
	[alertWindow setAutorecalculatesKeyViewLoop: true];

	//show alert
	var responseCode = [alert runModal];
	if(responseCode == '1000') {

		//== data options =======================

		//get randomize checkbox state
		var randomizeCheckbox = dataOptionsView.randomizeCheckbox;
		var randomizeData = Number([randomizeCheckbox state]);

		//get trim checkbox state
		var trimCheckbox = dataOptionsView.trimCheckbox;
		var trimText = Number([trimCheckbox state]);

		//get ellipsis checkbox state
		var ellipsisCheckbox = dataOptionsView.ellipsisCheckbox;
		var insertEllipsis = Number([ellipsisCheckbox state]);

		//get default substitute
		var substituteTextField = dataOptionsView.substituteTextField;
		var defaultSubstitute = [substituteTextField stringValue];

		//== layout options =====================

		//get create grid checkbox state
		var createGridCheckbox = layoutOptionsView.createGridCheckbox;
		var isCreateGrid = Number([createGridCheckbox state]);

		//get grid config
		var rowsCountTextField = layoutOptionsView.rowsCountTextField;
		var rowsCount = Number([rowsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var rowsMarginTextField = layoutOptionsView.rowsMarginTextField;
		var rowsMargin = Number([rowsMarginTextField stringValue].replace(/\,/g, '.'));
		var columnsCountTextField = layoutOptionsView.columnsCountTextField;
		var columnsCount = Number([columnsCountTextField stringValue].split(/[\.\,]/g)[0]);
		var columnsMarginTextField = layoutOptionsView.columnsMarginTextField;
		var columnsMargin = Number([columnsMarginTextField stringValue].replace(/\,/g, '.'));

		//save data options
		[defaults setObject: filePath forKey: 'dataPath'];
		[defaults setObject: 'JSON' forKey: 'populateMethod'];
		[defaults setObject: randomizeData forKey: 'randomizeData'];
		[defaults setObject: trimText forKey: 'trimText'];
		[defaults setObject: insertEllipsis forKey: 'insertEllipsis'];
		[defaults setObject: defaultSubstitute forKey: 'defaultSubstitute'];

		//save layout options
		[defaults setObject: isCreateGrid forKey: 'createGrid'];
		[defaults setObject: rowsCount forKey: 'rowsCount'];
		[defaults setObject: rowsMargin forKey: 'rowsMargin'];
		[defaults setObject: columnsCount forKey: 'columnsCount'];
		[defaults setObject: columnsMargin forKey: 'columnsMargin'];

		//sync defaults
		[defaults synchronize];

		//load data
		var data = Library.loadJSONData(filePath);

		//create grid
		if(isCreateGrid) {
			selectedLayers = Library.createGrid(selectedLayers, {
				rowsCount: rowsCount,
				rowsMargin: rowsMargin,
				columnsCount: columnsCount,
				columnsMargin: columnsMargin
			});
			selection = selectedLayers;

			//make sure that grid creation was successful
			if(!selectedLayers) {
				return;
			}
		}

		//populate design with data
		populate(data, selectedLayers, {
			rootDir: rootDir,
			randomizeData: randomizeData,
			trimText: trimText,
			insertEllipsis: insertEllipsis,
			defaultSubstitute: defaultSubstitute
		});
	}
}


function populateAgainHandler(_context) {
	context = _context;

	//get defaults
	var defaults = [NSUserDefaults standardUserDefaults];

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the layers you would like to populate.');
		return;
	}

	//get last used data path
	var lastDataPath = [defaults objectForKey: 'dataPath'];
	if(!lastDataPath) {
		context.document.showMessage('You must first use \'Populate with Preset\' or \'Populate with JSON\'.');
		return;
	}

	//get root dir
	var rootDir = [lastDataPath stringByDeletingLastPathComponent];

	//get options
	var randomizeData = Number([defaults objectForKey: 'randomizeData']);
	var trimText = Number([defaults objectForKey: 'trimText']);
	var insertEllipsis = Number([defaults objectForKey: 'insertEllipsis']);
	var defaultSubstitute = [defaults objectForKey: 'defaultSubstitute'];

	//check how last population was done
	var lastPopulateMethod = [defaults objectForKey: 'populateMethod'];

	//load data
	var data = Library.loadJSONData(lastDataPath);

	//populate design with data
	populate(data, selectedLayers, {
		rootDir: rootDir,
		randomizeData: randomizeData,
		trimText: trimText,
		insertEllipsis: insertEllipsis,
		defaultSubstitute: defaultSubstitute
	});
}


function revealPresetsHandler(_context) {
	context = _context;

	//get presets dir
	var presetDir = Library.getPresetsDir();

	//open dir
	var url = [NSURL fileURLWithPath: presetDir];
	[[NSWorkspace sharedWorkspace] openURL: url];
}


function insertImageHandler(_context) {
	context = _context;
	var doc = context.document;

	//get selection
	var selection = Library.getSelectedLayers();
	if(selection.length == 1) {
		var layer = selection[0];

		//make sure it's a shape group
		if(Library.isLayerShapeGroup(layer)) {

			//get last used location
			var defaults = [NSUserDefaults standardUserDefaults];
			var lastLocation = [defaults objectForKey: 'LastImageFilePickerLocation'];

			//ask for image
			var imageUrl = Library.askForImage(lastLocation);
			if(!imageUrl) return;

			//save last used location
			[defaults setObject: imageUrl forKey: 'LastImageFilePickerLocation'];
			[defaults synchronize];

			//load image
			var fileManager = [NSFileManager defaultManager];
			if ([fileManager fileExistsAtPath: imageUrl]) {
				var image = [[NSImage alloc] initWithContentsOfFile: imageUrl];

				//get shape group fill
				var fill = [[[layer style] fills] firstObject];

				//set pattern fill
				fill.setFillType(4);

				//set image as pattern fill
				var imageCollection = fill.documentData().images();
				[fill setPatternImage: image collection: imageCollection];
				fill.setPatternFillType(1);
			}

		}
		else {
			[doc showMessage: 'The selected layer is not a shape layer.'];
		}
	}
	else {
		[doc showMessage: 'Please select a single shape layer.'];
	}
}


function insertSVGHandler(_context) {
	context = _context;
	var doc = context.document;

	//get selection
	var selection = Library.getSelectedLayers();
	if(selection.length == 1) {
		var shapeGroup = selection[0];

		//make sure it's a shape group
		if(Library.isLayerShapeGroup(shapeGroup)) {

			//get last used location
			var defaults = [NSUserDefaults standardUserDefaults];
			var lastLocation = [defaults objectForKey: 'LastSVGFilePickerLocation'];

			//ask for image
			var svgUrl = Library.askForSVG(lastLocation);
			if(!svgUrl) return;

			//save last used location
			[defaults setObject: svgUrl forKey: 'LastSVGFilePickerLocation'];
			[defaults synchronize];

			//load image
			var fileManager = [NSFileManager defaultManager];
			if ([fileManager fileExistsAtPath: svgUrl]) {

				//remove existing temp page
				var existingTempPage = Library.findPageWithName('__TEMP_DATA_POPULATOR__', true);
				if(existingTempPage) {
					doc.removePage(existingTempPage);
				}

				//prepare temporary page
				var tempIconPage = Library.addPage('__TEMP_DATA_POPULATOR__');

				//get original placeholder icon frame
				var placeholderFrame = {
					x: shapeGroup.frame().x(),
					y: shapeGroup.frame().y(),
					width: shapeGroup.frame().width(),
					height: shapeGroup.frame().height()
				};

				//get shape group layers
				var placeholderSubLayers = Library.jsArray([shapeGroup layers]);

				//get file NSURL
				var fileUrl = [NSURL fileURLWithPath:svgUrl];

				//set up importer
				var SVGImporter = [MSSVGImporter svgImporter];

				//create temporary group for import
				var container = MSLayerGroup.new();
				container.setName('__IMPORTED_SVG__');

				//import svg into the container
				[MSDocumentImporter importFromURL: fileUrl inGroup: container importer: SVGImporter];

				//continue after delay to make sure import is complete
				Library.delay(function() {
					attemptImport();
				}, 0.01);


				function attemptImport() {

					//get container layers
					var containerLayers = Library.jsArray([container layers]);

					//there should only ever be one layer inside the container
					if(containerLayers.length >= 1) {

						//get layer
						var layer = containerLayers[0];

						//layer is a single shape group
						if([layer isKindOfClass: [MSShapeGroup class]]) {

							//get shape group layers
							var subLayers = Library.jsArray([layer layers]);

							//remove sub layers from imported shape group
							subLayers.forEach(function(subLayer) {
								subLayer.removeFromParent();
							});

							//add sub layers to original shape group
							shapeGroup.addLayers(subLayers);
						}

						//layer is a layer group containing more layers
						if([layer isKindOfClass: [MSLayerGroup class]] && ![layer isKindOfClass: [MSShapeGroup class]]) {

							//get group layers
							var subLayers = Library.jsArray([layer layers]);

							//create root shape
							var rootShape = [[MSShapeGroup alloc] init];

							//merge layers using union boolean operation
							[MSBooleanOperations mergeShapes:subLayers withShape:rootShape usingBooleanOp: 3];

							//get union shape group layers
							var unionSubLayers = Library.jsArray([rootShape layers]);

							//remove sub layers from imported shape group
							unionSubLayers.forEach(function(unionedSubLayer) {
								unionedSubLayer.removeFromParent();
							});

							//add sub layers to original shape group
							shapeGroup.addLayers(unionSubLayers);
						}

						//delete original placeholder sub layers from shape group
						placeholderSubLayers.forEach(function(placeholderSubLayer) {
							placeholderSubLayer.removeFromParent();
						});

						//get imported icon size
						var iconFrame = {
							x: shapeGroup.frame().x(),
							y: shapeGroup.frame().y(),
							width: shapeGroup.frame().width(),
							height: shapeGroup.frame().height()
						};

						//configure final frame
						var finalFrame = Library.scaleToBoundingBox(placeholderFrame, iconFrame, true);

						//set shape group frame
						shapeGroup.frame().setX(finalFrame.x);
						shapeGroup.frame().setY(finalFrame.y);
						shapeGroup.frame().setWidth(finalFrame.width);
						shapeGroup.frame().setHeight(finalFrame.height);

						//remove container
						container.removeFromParent();

						//remove temp page
						doc.removePage(tempIconPage);
					}
					else {

						//try again later
						Library.delay(function() {
							attemptImport();
						}, 0.01);
					}
				}
			}
		}
		else {
			[doc showMessage: 'The selected layer is not a shape layer.'];
		}
	}
	else {
		[doc showMessage: 'Please select a single shape layer.'];
	}
}


function restoreTextPlaceholdersHandler(_context) {
	context = _context;
	var doc = context.document;
	var command = context.command;

	//get selected layers
	var selectedLayers = Library.getSelectedLayers();
	selection = selectedLayers;
	if(!selectedLayers.length) {
		context.document.showMessage('Please select the text layers you would like to restore.');
		return;
	}

	//get all text layers and artboards in selection
	var textLayers = [];
	var artboards = [];
	var symbolInstances = [];
	selectedLayers.forEach(function(layer) {
		
		//add artboards too
		if(Library.isArtboard(layer)) {
			artboards.push(layer);
		}
		
		//get text layers from group
		else if(Library.isLayerGroup(layer)) {
			var nestedTextLayers = Library.findLayersInLayer(false, false, 'MSTextLayer', layer, false, false);
			textLayers = textLayers.concat(nestedTextLayers);
		}

		//add text layer
		else if(Library.isLayerText(layer)) {
			textLayers.push(layer);
		}
		else if(Library.isSymbolInstance(layer)) {
			symbolInstances.push(layer);
		}
	});

	//restore text layers
	textLayers.forEach(function(textLayer) {

		//get stored text from layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: textLayer];

		//replace text by original string including placeholders
		if(storedText) {

			//set text layer text
			textLayer.setStringValue(storedText);

			//resize text layer to fit text
			Library.refreshTextLayer(textLayer);
		}

		//remove text stored on layer
		[command setValue: nil forKey: 'textWithPlaceholders' onLayer: textLayer];
	});
	
	//restore artboard names
	artboards.forEach(function(artboardLayer) {
		
		//get stored text from layer
		var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: artboardLayer];

		//replace text by original string including placeholders
		if(storedText) {

			//set text layer text
			artboardLayer.setName(storedText);
		}

		//remove text stored on layer
		[command setValue: nil forKey: 'textWithPlaceholders' onLayer: artboardLayer];
	});
	
	//restore symbol instances
	symbolInstances.forEach(function(symbolInstance) {
		
		//remove overrides
		symbolInstance.setOverrides(null);
	});
}


function populate(data, selectedLayers, opt) {

    //keep track of already selected random indexes
    var randomIndexes = [];
    var lastRandomIndex = 0;

    //import state
    var numberOfSelectedLayers = selectedLayers.length;
    var currentLayerIndex = 0;
    var svgIconCount = 0;
    var svgIconsImported = 0;
    var svgIconsStartedImport = 0;

    //remove existing temp page
    var existingTempPage = Library.findPageWithName('__TEMP_DATA_POPULATOR__', true);
    if(existingTempPage) {
        var doc = context.document;
        doc.removePage(existingTempPage);
    }

    //prepare temporary page
    var tempIconPage = Library.addPage('__TEMP_DATA_POPULATOR__');

    //count svg icon placeholders in selection
    for(var i = 0; i < selectedLayers.length; i++) {
        var iconPlaceholders = Library.findLayersInLayer('{{*}}', false, 'MSShapeGroup', selectedLayers[i], false, false);
        svgIconCount += iconPlaceholders.length;
    }

    //populate population process
    populateSelection();


    function populateSelection() {

        //process each selected layer
        for(var i = 0; i < selectedLayers.length; i++) {
            currentLayerIndex = i;

            //get data row
            var dataRow;
            if(data instanceof Array) {
                if(opt.randomizeData) {

                    //reset random index tracking
                    if(randomIndexes.length == data.length) {
                        randomIndexes = [];
                    }

                    //get random index
                    var randomIndex;
                    while(!randomIndex && randomIndex !== 0) {

                        //get random in range
                        var random = Library.randomInteger(0, data.length);

                        //make sure index doesn't exist in already chosen random indexes
                        if(randomIndexes.indexOf(random) == -1) {

                            //make sure it's not the same as the last chosen random index
                            if(data.length > 1) {
                                if(random != lastRandomIndex) {
                                    randomIndex = random;
                                }
                            }
                            else {
                                randomIndex = random;
                            }
                        }
                    }

                    //store selected random index
                    lastRandomIndex = randomIndex;
                    randomIndexes.push(randomIndex);

                    //get data row for random index
                    dataRow = data[randomIndex];

                    //reset random index (so next iteration generates a new one)
                    randomIndex = null;
                }
                else {
                    dataRow = data[i % data.length];
                }
            }
            else {
                dataRow = data;
            }

            //check type of selected layer
            var selectedLayer = selectedLayers[i];
            if(Library.isLayerGroup(selectedLayer)) {
                
                //get all selected artboards and process them
                var artboards = Library.findLayersInLayer(false, false, 'MSArtboardGroup', selectedLayer, false, false);
                artboards.forEach(function(artboard) {
                    processArtboard(artboard, dataRow)
                });

                //get all text layers in selected layer
                var textLayers = Library.findLayersInLayer(false, false, 'MSTextLayer', selectedLayer, false, false);

                //process all text layers
                textLayers.forEach(function(textLayer) {
                    processTextLayer(textLayer, dataRow);
                });

                //find icon and image placeholders
                var colorPlaceholders = Library.findLayersInLayer('{{{*}}}', false, 'MSShapeGroup', selectedLayer, false, false);
                var iconPlaceholders = Library.findLayersInLayer('{{*}}', false, 'MSShapeGroup', selectedLayer, false, colorPlaceholders);
                var imagePlaceholders = Library.findLayersInLayer('{*}', false, 'MSShapeGroup', selectedLayer, false, colorPlaceholders.concat(iconPlaceholders));
                
                //find symbols
                var symbolInstances = Library.findLayersInLayer('*', false, 'MSSymbolInstance', selectedLayer, false, false);
                
                //process all symbol instances
                symbolInstances.forEach(function(symbolInstance) {
                    processSymbolInstance(symbolInstance, dataRow, opt.rootDir);
                });
                
                //process all image placeholders
                imagePlaceholders.forEach(function(shapeGroup) {
                    processImagePlaceholder(shapeGroup, dataRow, opt.rootDir);
                });

                //process all icon placeholders
                iconPlaceholders.forEach(function(shapeGroup) {
                    processIconPlaceholder(shapeGroup, dataRow, opt.rootDir);
                    svgIconsStartedImport++;
                });

                //process all color placeholders
                colorPlaceholders.forEach(function(shapeGroup) {
                    processColorPlaceholder(shapeGroup, dataRow, opt.rootDir);
                });
            }
            else if(Library.isLayerText(selectedLayer)) {
                processTextLayer(selectedLayer, dataRow);
            }
            else if(Library.isLayerShapeGroup(selectedLayer)) {

                //check if image or icon placeholder
                if([selectedLayer name].indexOf('{{') > -1) {
                    processIconPlaceholder(selectedLayer, dataRow, opt.rootDir);
                }
                else if([selectedLayer name].indexOf('{') > -1) {
                    processImagePlaceholder(selectedLayer, dataRow, opt.rootDir);
                }
            }
            else if(Library.isArtboard(selectedLayer)) {
                processArtboard(selectedLayer, dataRow);
            }
            else if(Library.isSymbolInstance(selectedLayer)) {
                processSymbolInstance(selectedLayer, dataRow, opt.rootDir);
            }
        }

        //if there were no svg icons, processing is now finished
        if(svgIconCount == 0) {

            //remove temp page
            Library.removePage(tempIconPage);

            //select original layers
            Library.restoreSelection();
        }
    }

    function findValueInDataRow(key, dataRow) {
        return _.get(dataRow, key);
    }

    function trimText(textLayer, text, insertEllipsis) {
    	
    	//test text length on a copy of the layer
		textLayer = Library.copyLayer(textLayer);
		
		//wake up stale text layers (strange issue)
		var opiginalContent = [textLayer stringValue];
		[textLayer setStringValue: '-'];
		Library.refreshTextLayer(textLayer);
		Library.resizeTextLayer(textLayer);
		[textLayer setStringValue: opiginalContent];
		Library.refreshTextLayer(textLayer);
		Library.resizeTextLayer(textLayer);
    	
    	//set text layer text
        textLayer.setStringValue(text);

        //resize text layer to fit text
        Library.refreshTextLayer(textLayer);
    	
    	//get original text layer height
        var textLayerFrame = textLayer.frame();
        var originalHeight = textLayerFrame.height();

        //resize to fit and get new height
        Library.resizeTextLayer(textLayer);
        var newHeight = textLayerFrame.height();

        //shorten text to fit
        var didTrim = (newHeight > originalHeight);
        while(newHeight > originalHeight) {
        	
            //trim last character
            text = text.substring(0, text.length - 1);

            //set trimmed text and re-evaluate height
            textLayer.setStringValue(text);
            Library.resizeTextLayer(textLayer);
            newHeight = textLayerFrame.height();
        }

        //if trimmed add ellipsis
        if(didTrim && insertEllipsis) {

            //add ellipsis
            text += '…';
            textLayer.setStringValue(text);
            Library.resizeTextLayer(textLayer);
            newHeight = textLayerFrame.height();

            //make sure that ellipsis fits in the text layer
            while(newHeight > originalHeight) {

                //remove character before ellipsis
                text = text.substring(0, text.length - 2);
                text += '…';

                //set new text with ellipsis
                textLayer.setStringValue(text);
                Library.resizeTextLayer(textLayer);
                newHeight = textLayerFrame.height();
            }
        }
        
        return text;
    }


    function processTextLayer(textLayer, dataRow) {
    	
        //reference command
        var command = context.command;

        //get stored text from layer
        var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: textLayer];

        //get text from text layer
        var text;
        if(storedText && storedText.length) {
            text = storedText;
        }
        else {
            text = [textLayer stringValue];
        }

        //store text on layer
        [command setValue: String(text) forKey: 'textWithPlaceholders' onLayer: textLayer];

        //merge text with values
        var mergedText = getPopulatedText(text, dataRow);

        //prevent bug with empty text layer
        if(!mergedText.length) {
            mergedText = '-';
            textLayer.setIsVisible(false);
        }
        else {
            textLayer.setIsVisible(true);
        }
        
        //check if text layer has fixed size and trimming activated
        if(textLayer.textBehaviour() == 1 && opt.trimText) {
        	mergedText = trimText(textLayer, mergedText, opt.insertEllipsis);
        }
        
        //set text layer text
        textLayer.setStringValue(mergedText);

        //resize text layer to fit text
        Library.refreshTextLayer(textLayer);

        //resize to fit
        Library.resizeTextLayer(textLayer);
    }
    
    function processSymbolTextLayer(textLayer, dataRow, overrides) {
        
        //get text from text layer (in the symbol master)
        var text = textLayer.stringValue();
        
        //reference command
        var command = context.command;
        
        //store text on layer (in symbol master)
        [command setValue: String(text) forKey: 'textWithPlaceholders' onLayer: textLayer];
        
        //merge text with values
        var mergedText = getPopulatedText(text, dataRow);
        
        //check if text layer has fixed size and trimming activated
        if(textLayer.textBehaviour() == 1 && opt.trimText) {
        	mergedText = trimText(textLayer, mergedText, opt.insertEllipsis);
        }

        //make text invisible by setting it to a space
        if(!mergedText.length) {
            mergedText = ' ';
        }
        
        //get id of text layer
        var layerId = textLayer.objectID();
        
        //add override for layer
        overrides.setValue_forKey(mergedText, layerId);
    }
    
    
    function getPopulatedText(text, dataRow) {
        
        //get placeholders in text
        var placeholders = getPlaceholders(text);

        //assign values to placeholders
        var values = {};
        placeholders.forEach(function(placeholder) {

            //solo/default placeholder
            if(placeholder.type == 'solo') {

                //get value
                var value = findValueInDataRow(placeholder.key, dataRow);

                //use substitute if value doesn't exist
                if(!value) {

                    if(placeholder.substitute) {

                        //use in-line substitute
                        value = String(placeholder.substitute);
                    }
                    else {

                        //use default substitute
                        value = '';
                    }
                }

                values[placeholder.string] = value;
            }
            else if(placeholder.type == 'enum') {

                //get values for sub placeholders
                var placeholderValues = [];
                placeholder.placeholders.forEach(function(subPlaceholder) {

                    //get value
                    var value = findValueInDataRow(subPlaceholder.key, dataRow);

                    //use substitute if value doesn't exist
                    if(!value) {

                        if(subPlaceholder.substitute) {

                            //use in-line substitute
                            value = String(subPlaceholder.substitute);
                        }
                        else {

                            //use default substitute
                            value = '';
                        }
                    }

                    //make sure value is not empty
                    if(value.length) placeholderValues.push(value);
                });

                //prepare enumerated value
                var enumeratedValue = '';
                if(placeholder.command == 'join') {
                    enumeratedValue = placeholderValues.join(placeholder.delimiter);
                }

                values[placeholder.string] = enumeratedValue;
            }
        });

        //merge text with values
        return Library.mergeStringWithValues(text, values);
    }
    
    function processSymbolInstance(symbolInstance, dataRow, rootDir) {
        
        //get overrides for symbol, including any nesteed symbols
        var overrides = overridesForSymbolInstance(symbolInstance, dataRow, rootDir);
        
        //set new overrides
        symbolInstance.setOverrides(NSDictionary.dictionaryWithObject_forKey(overrides, NSNumber.numberWithInt(0)));
    }
    
    function overridesForSymbolInstance(symbolInstance, dataRow, rootDir) {
        
        //get existing overrides
        var existingOverrides = symbolInstance.overrides();
        if(existingOverrides) {
            existingOverrides = symbolInstance.overrides().objectForKey(NSNumber.numberWithInt(0));
        } else {
            existingOverrides = NSDictionary.alloc().init();
        }
        
        //create mutable overrides
        var overrides = NSMutableDictionary.dictionaryWithDictionary(existingOverrides);
        
        //get master for symbol instance
        var symbolMaster = symbolInstance.symbolMaster();
        
        //get text layers in symbol
        var textLayers = Library.findLayersInLayer(false, false, 'MSTextLayer', symbolMaster, false, false);
        
        //process all text layers
        textLayers.forEach(function(textLayer) {
            processSymbolTextLayer(textLayer, dataRow, overrides);
        });

        //get image placeholders
        var colorPlaceholders = Library.findLayersInLayer('{{{*}}}', false, 'MSShapeGroup', symbolMaster, false, false);
        var iconPlaceholders = Library.findLayersInLayer('{{*}}', false, 'MSShapeGroup', symbolMaster, false, colorPlaceholders);
        var imagePlaceholders = Library.findLayersInLayer('{*}', false, 'MSBitmapLayer', symbolMaster, false, false);
        imagePlaceholders = imagePlaceholders.concat(Library.findLayersInLayer('{*}', false, 'MSShapeGroup', symbolMaster, false, colorPlaceholders.concat(iconPlaceholders)));
        
        //process all image placeholders
        imagePlaceholders.forEach(function(shapeGroup) {
            processSymbolImagePlaceholder(shapeGroup, dataRow, rootDir, overrides);
        });
        
        //find nested symbols
        var symbolInstances = Library.findLayersInLayer('*', false, 'MSSymbolInstance', symbolMaster, false, false);
        
        //process all symbol instances
        symbolInstances.forEach(function(nestedSymbolInstance) {
            var nestedOverrides = overridesForSymbolInstance(nestedSymbolInstance, dataRow, rootDir);
            overrides.setValue_forKey(nestedOverrides, nestedSymbolInstance.objectID());
        });
        
        return overrides;
    }


    function processArtboard(artboard, dataRow) {
        
        //reference command
        var command = context.command;

        //get stored text from artboard layer
        var storedText = [command valueForKey: 'textWithPlaceholders' onLayer: artboard];

        //get text from text layer
        var text;
        if(storedText && storedText.length) {
            text = storedText;
        }
        else {
            text = [artboard name];
        }

        //store text on layer
        [command setValue: String(text) forKey: 'textWithPlaceholders' onLayer: artboard];
        
        //get placeholders in text
        var placeholders = getPlaceholders(text);

        var values = {};
        placeholders.forEach(function(placeholder) {
            if(placeholder.type == 'solo') {
                var value = findValueInDataRow(placeholder.key, dataRow);

                if(!value) {
                    if(placeholder.substitute) {
                        value = String(placeholder.substitute);
                    } else {
                        value = '';
                    }
                }

                values[placeholder.string] = value;
            }
            else if(placeholder.type == 'enum') {
                var placeholderValues = [];

                placeholder.placeholders.forEach(function(subPlaceholder) {
                    var value = findValueInDataRow(subPlaceholder.key, dataRow);

                    if(!value) {
                        if(subPlaceholder.substitute) {
                            value = String(subPlaceholder.substitute);
                        } else {
                            value = '';
                        }
                    }

                    if(value.length) placeholderValues.push(value);
                });

                var enumeratedValue = '';
                if(placeholder.command == 'join') {
                    enumeratedValue = placeholderValues.join(placeholder.delimiter);
                }

                values[placeholder.string] = enumeratedValue;
            }
        });

        var mergedText = Library.mergeStringWithValues(text, values);
        if(!mergedText.length) {
            mergedText = '-';
        }

        [artboard setName: mergedText];
    }
    
    
    function processSymbolImagePlaceholder(shapeGroup, dataRow, rootDir, overrides) {
        
        //get image data
        var imageData = getImageData(shapeGroup, dataRow, rootDir);
        
        //get shape group fill
        var fill = [[[shapeGroup style] fills] firstObject];

        //set pattern fill for shape group in case it isn't already
        fill.setFillType(4);
        fill.setPatternFillType(1);
        
        //get id of text layer
        var layerId = shapeGroup.objectID();
    
        //add override for layer
        if(imageData) {
        	overrides.setValue_forKey(imageData, layerId);
        }
        else {
        	overrides.setValue_forKey(null, layerId);
        }
    }
    
    
    function getImageData(shapeGroup, dataRow, rootDir) {
        
        //get shape group name
        var shapeGroupName = [shapeGroup name].toString();

        //get placeholder name
        var placeholder = shapeGroupName.substring(1, [shapeGroupName length] - 1);

        //get image url for placeholder from data row
        var imageUrl = findValueInDataRow(placeholder, dataRow);
        if(!imageUrl) return;
        if(imageUrl[0] == '/') imageUrl = imageUrl.substring(1);

        //build full image url
        var fullImageUrl = [rootDir stringByAppendingPathComponent: imageUrl];

        //load image
        var fileManager = [NSFileManager defaultManager];
        if ([fileManager fileExistsAtPath: fullImageUrl]) {
            var image = [[NSImage alloc] initWithContentsOfFile: fullImageUrl];
            var imageData = [[MSImageData alloc] initWithImage: image convertColorSpace: false]];
            return imageData;
        }

        // Regular expression to match URL images
        var urlRegexp = new RegExp('(http)[s]?(://)');

        // Conditional test for image
        if (urlRegexp.test(imageUrl)) {
            
            //get image from url
            var image = Library.getImageFromURL(imageUrl);
            
            //make sure that image was loaded successfully
            if(!image) {
                context.document.showMessage('Some images could not be downloaded. Please check the URLs.');
                return;
            }
            
            //create image data from image
            var imageData = [[MSImageData alloc] initWithImage: image convertColorSpace: false]];
            return imageData;
        }
    }
    

    function processImagePlaceholder(shapeGroup, dataRow, rootDir) {
        
        //get image data
        var imageData = getImageData(shapeGroup, dataRow, rootDir);
        
        //get shape group fill
        var fill = [[[shapeGroup style] fills] firstObject];
            
        //set fill
        if(imageData) {

            //enable fill
            fill.setIsEnabled(true);

            //set pattern fill
            fill.setFillType(4);
            [fill setImage: imageData];
            fill.setPatternFillType(1);
        }
        else {
            
            //disable fill
            fill.setIsEnabled(false);
        }
    }
    

    function processIconPlaceholder(shapeGroup, dataRow, rootDir) {

        //get shape group name
        var shapeGroupName = [shapeGroup name].toString();

        //get placeholder name
        var placeholder = shapeGroupName.substring(2, [shapeGroupName length] - 2);

        //get icon url for placeholder from data row
        var iconUrl = findValueInDataRow(placeholder, dataRow);
        if(!iconUrl) {
            svgIconsImported++;

            //hide placeholder
            shapeGroup.setIsVisible(false);

            //check if all icons for selection are imported now
            if(svgIconsImported == svgIconCount) {

                //remove temp page
                Library.removePage(tempIconPage);

                //select original layers
                Library.restoreSelection();
            }

            return;
        }
        else {

            //show placeholder
            shapeGroup.setIsVisible(true);
        }
        if(iconUrl[0] == '/') iconUrl = iconUrl.substring(1);

        //build full icon url
        var fullIconUrl = [rootDir stringByAppendingPathComponent: iconUrl];

        //import icon
        var fileManager = [NSFileManager defaultManager];
        if ([fileManager fileExistsAtPath: fullIconUrl]) {

            //get original placeholder icon frame
            var placeholderFrame = {
                x: shapeGroup.frame().x(),
                y: shapeGroup.frame().y(),
                width: shapeGroup.frame().width(),
                height: shapeGroup.frame().height()
            };

            //get shape group layers
            var placeholderSubLayers = Library.jsArray([shapeGroup layers]);

            //get file NSURL
            var fileUrl = [NSURL fileURLWithPath:fullIconUrl];

            //set up importer
            var SVGImporter = [MSSVGImporter svgImporter];

            //create temporary group for import
            var container = MSLayerGroup.new();
            container.setName('__IMPORTED_SVG__');

            //import svg into the container
            [MSDocumentImporter importFromURL: fileUrl inGroup: container importer: SVGImporter];
            
            //continue after delay to make sure import is complete
            Library.delay(function() {
                attemptImport();
            }, 0.01);


            function attemptImport() {

                //get container layers
                var containerLayers = Library.jsArray([container layers]);

                //there should only ever be one layer inside the container
                if(containerLayers.length >= 1) {

                    //get layer
                    var layer = containerLayers[0];

                    //layer is a single shape group
                    if([layer isKindOfClass: [MSShapeGroup class]]) {

                        //get shape group layers
                        var subLayers = Library.jsArray([layer layers]);

                        //remove sub layers from imported shape group
                        subLayers.forEach(function(subLayer) {
                            subLayer.removeFromParent();
                        });

                        //add sub layers to original shape group
                        shapeGroup.addLayers(subLayers);
                    }

                    //layer is a layer group containing more layers
                    if([layer isKindOfClass: [MSLayerGroup class]] && ![layer isKindOfClass: [MSShapeGroup class]]) {

                        //get group layers
                        var subLayers = Library.jsArray([layer layers]);

                        //create root shape
                        var rootShape = [[MSShapeGroup alloc] init];

                        //merge layers using union boolean operation
                        [MSBooleanOperations mergeShapes:subLayers withShape:rootShape usingBooleanOp: 3];

                        //get union shape group layers
                        var unionSubLayers = Library.jsArray([rootShape layers]);

                        //remove sub layers from imported shape group
                        unionSubLayers.forEach(function(unionedSubLayer) {
                            unionedSubLayer.removeFromParent();
                        });

                        //add sub layers to original shape group
                        shapeGroup.addLayers(unionSubLayers);
                    }

                    //delete original placeholder sub layers from shape group
                    placeholderSubLayers.forEach(function(placeholderSubLayer) {
                        placeholderSubLayer.removeFromParent();
                    });

                    //get imported icon size
                    var iconFrame = {
                        x: shapeGroup.frame().x(),
                        y: shapeGroup.frame().y(),
                        width: shapeGroup.frame().width(),
                        height: shapeGroup.frame().height()
                    };

                    //configure final frame
                    var finalFrame = Library.scaleToBoundingBox(placeholderFrame, iconFrame, true);

                    //set shape group frame
                    shapeGroup.frame().setX(finalFrame.x);
                    shapeGroup.frame().setY(finalFrame.y);
                    shapeGroup.frame().setWidth(finalFrame.width);
                    shapeGroup.frame().setHeight(finalFrame.height);

                    //remove container
                    container.removeFromParent();

                    //count the imported icon
                    svgIconsImported++;

                    //check if all icons for selection are imported now
                    if(svgIconsImported == svgIconCount) {

                        //remove temp page
                        Library.removePage(tempIconPage);

                        //select original layers
                        Library.restoreSelection();
                    }
                }
                else {

                    //try again later
                    Library.delay(function() {
                        attemptImport();
                    }, 0.01);
                }
            }
        }
        else {
            svgIconsImported++;
        }
    }
    

    function processColorPlaceholder(shapeGroup, dataRow, rootDir) {

        //get shape group name
        var shapeGroupName = [shapeGroup name].toString();

        //get placeholder name
        var placeholder = shapeGroupName.substring(3, [shapeGroupName length] - 3);

        //get hex color for placeholder from data row
        var hexColor = dataRow[placeholder];

        if(!hexColor) {
            
            //hide placeholder
            shapeGroup.setIsVisible(false);
            return;
        }
        else {
            
            //show placeholder
            shapeGroup.setIsVisible(true);
        }

        //get shape group fill
        var fill = [[[shapeGroup style] fills] firstObject];

        //enable fill
        fill.setIsEnabled(true);

        //set pattern fill
        fill.setFillType(0);

        // set the color
        fill.color = [MSColor colorWithSVGString:hexColor];
    }
    

    function getPlaceholders(str) {

        //collect placeholders
        var results = [];

        //regex matching
        var re = /{([^}]+)}/g;
        var text;

        //find placeholders
        while(text = re.exec(str)) {

            //get inside of placeholder (between {})
            var placeholderText = text[1];

            //check if placeholder uses enumeration syntax
            if(placeholderText.indexOf('|&') > -1) {

                //split enum placeholder text into components
                var placeholderComponents = placeholderText.split('|&');

                //get placeholders
                var placeholdersString = placeholderComponents[0] || '';
                var placeholderStrings = placeholdersString.split(',');
                var placeholders = [];
                placeholderStrings.forEach(function(placeholderString) {

                    //process placeholder string
                    var placeholder = processPlaceholderString(placeholderString.trim());
                    placeholders.push(placeholder);
                });

                //get delimiter
                var delimiter = placeholderComponents[1] || '';

                //create object
                results.push({
                    string: placeholderText,
                    type: 'enum',
                    command: 'join',
                    delimiter: delimiter,
                    placeholders: placeholders
                });
            }
            else {

                //process placeholder text
                var placeholder = processPlaceholderString(placeholderText);
                results.push(placeholder);
            }
        }

        function processPlaceholderString(placeholderString) {

            //split into components
            var placeholderComponents = placeholderString.split('?');

            //check if has substitute
            var hasSubstitute = (placeholderComponents.length == 2);
            if(hasSubstitute) {

                //get key and substitute
                var key = placeholderComponents[0].trim();
                var substitute = placeholderComponents[1].trim();

                //set default substitute
                if(!substitute.length) substitute = opt.defaultSubstitute;

                return {
                    type: 'solo',
                    string: placeholderString,
                    key: key,
                    substitute: substitute
                };
            }
            else {

                return {
                    type: 'solo',
                    string: placeholderString,
                    key: placeholderString
                };
            }
        }

        return results;
    }
}